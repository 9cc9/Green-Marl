Procedure randomwalk(G : Graph, seed : Node(G), ratio : Double, nodes : Node_Set(G)) {
	   	
	Int remaining = (Int)(G.NumNodes() * ratio);
	Int switch = 0;
	Node_Property<Bool> visited;
	G.visited = False;
	Node current = seed;

	While(remaining > 0) {
		If(switch == 0) {
			Int nodeCount = G.NumNodes();
			[seed = (node_t)(rand() % nodeCount)];
			current = seed;
			If(!current.visited) {
				remaining = remaining - 1;
				current.visited = True;
			}
			switch = 100 * G.NumNodes();
		}

		Int outNbrCount = Count(n : current.OutNbrs);
		If(outNbrCount == 0) {
			switch = 0; //no out edges -> select new seed
		} Else {
			//jump home?
			If(Uniform() < 0.15) {
				current = seed; //jump home
			} Else {
				Int select = Uniform() * Count(n : current.OutNbrs);
				Node tmp = current;
				For(n : current.OutNbrs) {
					If(select == 0) tmp = n;
					select = select - 1;		
				}
				current = tmp;
				If(!current.visited) {
					remaining = remaining - 1;
					current.visited = True;
				}
				current.visited = True;
				switch = switch - 1;
			}
		}
	}

	Foreach(n : G.Nodes) (n.visited)
		nodes.Add(n);
}
