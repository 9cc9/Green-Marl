
1. Introduction
====================================

  Green-Marl [1] is a domain-specific language that is specially designed for
  graph data analysis. For the further information for the Green-Marl language,
  refer to the language specification draft [2], which can also  be found in
  this directory in the source package.

  'gm_comp' is a compiler for Green-Marl. It reads a Green-Marl file and
  generates an equivalent, efficient and parallelized  C++ implementation, i.e.
  .cc file.  More specifically, the compiler produces a C++ function for each
  Green-Marl procedure.  The generated c++ functions can be compiled with gcc
  and therefore can be merged into any user application that are compilable
  with gcc.

  The C++ codes that are generated by 'gm_comp' assume the following libraries:
    - gcc (with builtin atomic functions)
    - gcc (with OpenMp support)
    - a custom graph library and runtime (gm_graph) 
  The first two are supported by any recent gcc distributions (version 4.2 or
  higher); the third one is included in this source package.
    
  'gm_comp' is also able to generate codes for a completely different target
  environment (See Section 5).



2. The Package 
====================================

2.1 Obtaining this package
-------------------------------------

  [XXXX: describe how to get this package.]


2.2 Directories
-------------------------------------

  <top>:       Top directory where you put your source package

  <top>/src :  Compiler source code
  <top>/obj :  Object (.o) files during compilation [to be generated]
  <top>/test:  Test routines for compiler development
  <top>/bin :  Compiler binary (gm_comp) [to be generated]
  <top>/etc :  Extra files for enhanced your experience
  <top>/doc :  Documents
  <top>/apps:  Sample Green-Marl applications and runtime library

  <top>/apps/src                  : Sample Green-Marl programs
  <top>/apps/output_cpp           : Directory for Green-Marl to C++ 
  <top>/apps/output_cpp/generated : C++ codes generated by the gm_comp [to be generated]
  <top>/apps/output_cpp/src       : C++ 'main' code for sample applications
  <top>/apps/output_cpp/data      : Directory for data files  [to be generated]
  <top>/apps/output_cpp/bin       : Directory for compiled binaries [to be generated]
  <top>/apps/output_cpp/gm_graph  : gm_graph (C++ runtime and graph library)

  <top>/apps/output_cpp/gm_graph/src  : source  files (.cc) for gm_graph
  <top>/apps/output_cpp/gm_graph/inc  : header  files (.h)  for gm_graph
  <top>/apps/output_cpp/gm_graph/lib  : gm_graph library (.a) [to be generated]

  <top>/apps/output_gps           : Directory for Green-Marl to GPS


3. The compiler
====================================

3.1 System Requirements
-------------------------------------

  The compiler(gm_comp) and runtime(gm_graph) requires the following
  environments:
    - POSIX environment: linux or unix, (not tested with cygwin)
    - x86 instruction-set architecture (i386 or x86_64)
    - gcc (version >= 4.2), which supports OpenMp
    - GNU flex and bison 

3.2 Directory Generation
-------------------------------------

  The following steps generates a set of empty directories that will be used during
  compilation. 
    (a) cd to <top>
    (b) './make_dirs.sh'

3.3 Build the Compiler
-------------------------------------

  The following steps build up 'gm_comp', a Green-Marl compiler:
    (a) cd to <top>/src
    (b) 'make'
    (c) check if <top>/bin/gm_comp has been created successfully.
    (d) cd to <top>/bin and type 'gm_comp -h' to look at compiler options

  A more detailed documentation about the gm_comp compiler can be found in
  XXXX.txt in this directory.

3.3 Installing Syntax Highlighting for vi
-------------------------------------

  Vi users can enable syntax highlighting of Green-Marl programs (.gm files) 
  through the following steps:
    (a) copy etc/vim/syntax/greenmarl.vim into ~/.vim/syntax/
    (b) copy etc/vim/ftdetect/greenmarl.vim into ~/.vim/ftdetect/


4. Compiling and Executing Sample Applications
====================================

4.1 The Applications
-------------------------------------

  This package includes four sample Green-Marl programs (<top>/apps/src/). All
  the programs are classic graph algorithms implemented in Green-Marl. Take a
  look at each program (*.gm) and see how each algorithm is described
  intuitively with Green-Marl.

  (a) Betweenness Centrality (bc.gm)
    Computes (estimated) betweenness centrality of each node in the given
    graph.  The algorithm performs BFS only from a given sequence of nodes,
    instead of every node in the graph.

  (b) Conductance (conductance.gm)
    Computes the conductance of the given subset of nodes in a graph. Here,
    the subset is represented with 'membership' property; i.e., each
    node has group ID, where it belongs.

  (c) PageRank (pagerank.gm)
    Computes pagerank of each node in the given graph.

  (d) Strongly connected components (kosaraju.gm)
    Finds strongly connected components of a given graph, using Kosaraju's
    algorithm. The original algorithm performs two DFS traversal of a graph --
    one on the original graph, and the other on its transposed graph. However,
    the second DFS is replaced with BFS, in order to improve performance.


4.2 Compiling Green-Marl Programs with gm_comp
-------------------------------------

  The following steps compiles sample Green-Marl programs into C++:
    (a) cd to <top>/apps
    (b) check the content of the file "Programs.mk"
        ; this file contains the names of Green-Marl programs to be compiled
        (without any file extension).
    (c) 'make gen'
        ; this invokes <top>/bin/gm_comp and creates c++ implementation
        (.cc, .h file) from each Green-Marl program (.gm file).
    (d) check <top>/output_cpp/generated/ and see *.cc files are successfully
        generated.


4.3 Compiling Graph and Runtime Library
-------------------------------------

  Every code generated by gm_comp assumes a specific runtime/graph library,
  namely gm_graph. The source codes of gm_graph library is also included 
  in this package (<top>/apps/output_cpp/gm_graph).

  gm_graph library can be built through the following steps:
    (a) cd to <top>/apps/
    (b) 'make lib'
    (c) check libgmgraph.a has been successfully created in 
        <top>/apps/output_cpp/gm_graph/lib

  Note that this step is required only once for each package release.  A more
  detailed documentation about gm_graph library can be found in XXXX.txt


4.4 Compiling the Generated C++ Files
-------------------------------------

  First, we remind the readers that he codes generated by gm_comp are C++
  'functions' that should be invoked by 'main' application. Thus, this package
  provides example 'main functions' for all the sample Green-Marl programs in
  <top>/apps/src. The main file of each program is named as <program
  name>_main.cc
   
  All the 'main functions' do the same things -- (1) it reads out the graph
  (binary) from the given filename, (2) prepares other input data, and (3)
  invokes the procedure generated by gm_comp, using given number of threads. 

  Note that the user is free to create his/her own main functions in any case.

  Now we can compile the codes generated by gm_comp through the following
  steps:
    (a) cd to <top>/apps/
    (b) 'make bin'
    (c) check if executables are successfully generated at
    <top>/apps/output_cpp/bin

4.5 Short Cut
-------------------------------------

  There is a short cut that does all of 4.2~4.4 at one command.
   (a) cd to <top>/apps/
   (b) 'make all'
       ; this does all of 'make lib', 'make gen', and 'make bin' in order.


4.6 Executing sample programs
-------------------------------------

  [XXXX] (Make graph_gen as a separate package; it is polluted by GPL from GT.)
  (Or, we can remove RMAT graph generation functionality from graph_gen)

  To execute sample programs, we need at least one graph instance. For this
  purpose, let us first synthesis a graph using an external tool named
  graph_gen. graph_gen is a simple tool that generates syntactic graphs and
  stores it using binary files.  One can get graph_gen from <XXXX>. Here, we
  assume that graph_gen executable has been built and copied into
  <top>/apps/output_cpp/bin/.

  Now, do the following steps:
    (a) cd to <top>/apps/output_cpp
    (b) 'bin/graph_gen 1000000 8000000 data/u1m_8m.bin 0'
        ; this synthesizes a uniform random graph that has 1 million nodes
        and 8 million edges.
    (c) 'bin/conduct data/u1m_8m.bin 1'
        ; the program divides the nodes of the graph (u1m_8m.bin) into 4
        partitions, computes the conductance value of each partition, and
        prints out the sum of 4 conductance values.
    (d) 'bin/conduct data/u1m_8m.bin 8'
        ; do the same thing as (c) but with using 8 threads.
    (e) The remaining programs (pagerank, bc, kosaraju) have the same command-line
        argument format.
           <program name> <graph name> <# of threads>
        

4.7 Adding your own Green-Marl Program
-------------------------------------

   Refer to etc/tutorial.txt which provides a walk-through to write your own Green-Marl
   program, to compile it, and to execute it.


5. Generating GPS output
====================================

  The usage model of the Green-Marl language is not restricted to the cache-coherent
  shared-memory multi-processor environment. A program written in Green-Marl can be
  compiled into another program that runs on a completely different target environment.

  'gm_comp' can translate (a subset of) Green-Marl programs into Java codes
  that run on a Pregel[3]-like framework. Pregel[3] is a framework that enables
  distributed execution of graph algorithms that are written on its API.
  However, the way Pregel API is designed is far from the way graph algorithms are 
  normally designed; often the user should re-design his/her algorithm completely,
  in order to comply with the API.

  Green-Marl aims to solve this problem: the user can write his/her algorithm
  in a natural way, while the compiler automatically re-write the algorithm
  into the API.

  Currently, gm_comp can translate a certain subset of Green-Marl programs into
  GPS application; GPS is a custom replicate of Pregel[3] with a few enhancements.  
  This GPS back-end of gm_comp is still in early development stage.

  To see how gm_comp with GPS works, try following steps: 
     (1) cd to <top>/apps
     (2) 'make env=gps PROGS="gps_test gps_test2"'
     (3) Check if <top>/apps/output_gps/generate/*.java has been created successfully.

  Note that a simple Green-Marl code (e.g. gps_test.gm) are turned into a very
  complicated java class; all these methods are required to comply with
  Pregel(GPS) API.  The compiler automatically generates all these stuffs.


6. License
====================================

   [XXXX. add license information here]


7. References
====================================

[1] S. Hong et al, "Green-Marl: A DSL for easy and efficient graph analysis", ASPLOS 2012
[2] Green-Marl language specification (draft ver. 0.3)
[3] G. Malewicz et al, "Pregel: A System for Large Scale Graph Processing", SIGMOD 2010.

