1 Introduction
======================================

This document provides a brief explanation about gm_comp, a 
Green-Marl compiler. gm_comp reads a Green-Marl program and generates
equivalent code for the target environment. Currently gm_comp is able
to generate C++ code for cache coherent shared-memory environment, and
Java code for distributed execution based on a Pregel-Like environment. 

Please refer to [Readme documentary](../README.md) which explains
how to set up and build the compiler; once you finish following that document,
gm_comp should be created at $(top)/bin.


2 Using the Compiler
========================================


2.1 Compiler Options
----------------------------------------

The following command will show the available compiler options:

    cd ($top)/bin
    ./gm_comp -h

 * Currently, the compiler can process only one input file at a time.
 * -h option shows the help message
 * -v option prints the version 
 * -t=\<string\> option selects the target environment
     + cpp_omp : generate multi-threaded C++ implementation using OpenMP
     + cpp_seq : generate single-threaded C++ implementation 
                 (TODO: still some library initialization routine uses OpenMp internally.)
     + gps     : generate java implementation for GPS environment
 * -o=\<string\> option specifies where the generated file will be located. Default is ./ 

The next four options are used to track-down what compiler is doing with given code. 

 * -V=\<int\> option specifies compiler verbosity level. Default is 0.
     + -V=1: shows the name of each compilation step
 * -DS=\<string\> option lets the user to stop the compiler after certain stage.
 * -Dr=1 option lets the compiler to reproduce Green-Marl code when it is  stopped by -DS option.
 * -Dw=1 option lets the compiler to print rw analysis information when it is stopped.



2.2 Tracking Compiler Optimization
----------------------------------------

gm_comp allows the user to stop the compiler at any step, and to reproduce the Green-Marl code again, 
but with all the optimizations up to that point being applied. This is very helpful to debug your program 
(or debug the compiler and blame the authors of the compiler).

Let us try this with an example. Make a short Green-Marl program named foo.gm

    Proc foo (G:Graph, A,B: N_P<Int>(G)) : Int // Proc is a short-hand for Procedure, N_P for Node_Property
    {
        Int X = Sum(s:G.Nodes) {s.A};
        Int Y = Sum(t:G.Nodes) {t.B};
        Return X*Y;
    }

Now let us compile this with verbosity option; the compiler will print out 
a message at each stage it is perfoming.
(The printed result may differ slightly depending on the compiler version).

    ./gm_comp -V=1 foo.gm
    ......
    ...Stage 2.1: Frontend.[Check syntax rules]
    ...Stage 2.2: Frontend.[Regularize syntax (without typeinfo)]
    ......
    ...Stage 3.2: Indep-Opt.[Regularize syntax]
    ......
    ...Stage 3.6: Indep-Opt.[Merge loops]
    ......
    ...Stage 6.8: Code Generation.[Creating source for each procedure]

The compiler goes through 6 major steps.

  * 1: Parsing
  * 2: Type and Data-race Checking
  * 3: Backend Independant Optimization
  * 4: Backend Specific Optimization
  * 5: Library Specific Optimization
  * 6: Code Generation



2.3 Using vi + make + gm_comp
----------------------------------------

If gm_comp is invoked by make, which is again invoked inside vi (by :make), 
vi will capture any the error message generated by gm_comp during make,
and jump to the error location automatically.




3 C++ Backend
========================================




4 GPS Backend
========================================



4 Known Issues (To be resolved: before _real_ release)
========================================

* Currently, it is not possible for a Green-Marl procedure to make a call to other GM procedures 
  However, this can be circumvented a little bit, since the main function can make
  function calls to those procedures.


* Implementation of parallel addition/removal to the collection has not finished. 
     + Compiler should check the mutation gender inside parallel region.
       (should not allow concurrent removal and additioin at the same time.)
     + Compiler should apply appropriate interface to the collection.
        (e.g. add_seq vs add_par, depending on the context)

* Ad-hoc implementation used for paper submission is now being re-implemented.
     + Argmax implementation
     + Flipping edge optimization
     + Saving BFS children optimization
     + (node iterator).edge()
