1 Introduction
======================================

This document provides a walk-through to write down your own Green-Marl
program and to execute it.  Before proceed, please read $(top)/Readme.md and
follow the steps in the document, which guides you to build up the
compiler and runtime library properly.


2 First program: Hello World
======================================

Now let us write the traditional "Hello World" application with Green-Marl.
Note that we will re-use the _makefile_ scripts that are already provided with the sample
application. However, this is not mandatory but you are free to create your own
makefile scripts, once you're accustomed to Green-Marl environment.

Also we recommend to use vim as a text editor, because we provide vim
Syntax-Highlighting support for Green-Marl. See README.md for details.


2-1 Writing hello_world.gm
--------------------------------------

We will add our new program in $(top)/apps/src
    
    cd $(top)/apps/src
    vi hello_world.gm    %% Start write your code with vi

Now write your first Green-Marl program as follows:

    Procedure hello_world() 
    {
        [ printf("Hello world\n") ];
    }
    
Unfortunately, hello_world program does not exercise much of interesting features of Green-Marl.

**Procedure** is a keyword that indicates a Green-Marl procedure, followed by procedure name and
argument lists (inside parenthesis) and the procedure body (inside braces).

There is only one statement in the body. Interestingly the statement is enclosed within a bracket \[ \]. 
This denotes _foreign statement_ in Green-Marl, which means that any string inside a bracket
is not Green-Marl statements but the statements of the target language, which in our case is C++. The compiler
will simply reproduce this string in the proper place, when generating the target code.


2-2 Compiling hello_world.gm
--------------------------------------

Now we will compile hello_world.gm into target (i.e. C++) code. 
First, let's add hello_world progam to our Makefile script.

    cd $(top)/apps
    vi Programs.mk
    %%%% Programs.mk has the following line:
    %%%%    PROGS=pagerank conduct bc kosaraju 
    %%%% Add hello_world at the end of it:
    %%%%    PROGS=pagerank conduct bc kosaraju hello_world
    
Now we can compile the hello_world program through the following command:

    cd $(top)/apps
    make gen         %% this command generates .cc file out of .gm file
    ls $(top)/apps/output_cpp/generated/hello_world.cc   % check the code has been well created.
 
In fact, the actual shell command invoked by the previous make is as following:

    cd $(top)/apps/src
    ../../bin/gm_comp -o=../output_cpp/generated -t=cpp_omp hello_world.gm
    
The command is invoking gm_comp compiler with 
  -o option (where to put generated code) and
  -t option (what is the target environment; cpp_omp means C++ with OpenMP)
in addition to the source file, hello_world.gm

Before we move on, let us take a look at what is the generated code look like.

    cd $(top)/apps/output_cpp/generated/
    cat hello_world.cc 
    % The generated code shall look like as follows: (may differ slightly depending on compiler version)
    #include "hello_world.h"
    
    void hello_world()
    {
       // Initializations
       gm_rt_initialize();
       
       printf("hello_world\n");
    }
    
Noticeablly, the compiler inserted _runtime_ initialization code at the function entry. 
(If the runtime has been already initialized, the call to `gm_rt_initialization()` returns
immediatedly.) Other than that, the compiler simply reporduced foreign syntax in place, as expected.


2-3 Creating an executable and Running it
--------------------------------------
Now let us execute the hello_world program on your system.

Notice that your hello_world.cc is a normal c++ file without any `main()` method in it; 
it simply contains one function `hello_world()`, which can be invoked from the `main()` or any other
c++ functions.

Therfore we first create a main file as follows:

    cd $(top)/apps/output_cpp/src
    vi hello_world_main.cc         %% Our makefile script assumes {program}_main.cc 

Write your main function as follows:

    #include "hello_world.h"         // header generated by gm_comp
    
    int main(int argc, char** argv)
    {
        hello_world();               // call to the generated function
    }


Now we can compile the code with the following command:

    cd $(top)/apps/output_cpp/src
    make 
    ls $(top)/apps/output_cpp/bin/hello_world   % check the binary has been created successfully

Before we execute the program, let us review the actual command invoked by the last `make`.
In fact it has invoked g++ nothing but in a quite normal way:
    
    g++ -O3 -g -I../generated -I../gm_graph/inc -I. -fopenmp   ../generated/hello_world.cc hello_world_main.cc 
        -L../gm_graph/lib -lgmgraph -o ../bin/hello_world

* g++ compiler compiles two source fiels hello_world.cc and hello_world_main.cc
* -I option specifies include paths. ../gm_graph/inc is where the header files for the gm_graph is located. 
  ../generated/ contains headers generated by gm_comp
* -fopenmp option specifies that the program uses OpenMp. 
  (In this example, openMp is used inside the runtime library.)
* The progam is linked with the runtime and graph library (gm_graph). 
  -L options specifice where to find the library.

Okay, now we are ready to run your hello_world application.

    cd $(top)/apps/output_cpp/bin/
    ./hello_world     % "hello world" should be printed out. 
    



3 Second program: sum of neighbors' in-degree.
======================================

Now we will create another Green-Marl program, which performs a more graph-analytic procedure. 
In this procedure, for each node in the graph, we will compute the sum of its neighbors' in-degree.
This is like, for example, in Twitter network you are summing up the number of followers of 
all of your followees. Once we get this number for every node, we will add up all these numbers 
as the final output value. 


For the sake of convenience, instead of creating another .gm file, we will simply add 
another procedure in hello_world.gm. 

3-1 Another Green-Marl procedure
--------------------------------------

Edit your $(top)/apps/src/hello_world.gm in following ocde. 
Note that // denotes line-comment just like in C++.

    // your previous procedure
    Procedure hello_word() 
    {      
       [printf("hello world");]
    }
    
    //-----------------------------------------------------
    // Your new procedure. (Proc is a short-hand for Procedure)
    //-----------------------------------------------------
    //   *  G is a directed graph
    //   *  NSum is a node property (i.e. data associated with each node) of G, 
    //      where the type of each data is Int; NSum will be computed by this procedure.
    //   *  This procedure returns an Int value as well (sum of NSum).
    //-----------------------------------------------------
    Proc sum_of_nbr_in_degree(G: Graph, 
                              NSum: Node_Prop<Int>(G)) : Int                           
    {   
        // For each node s in the graph,
        //    assign NSum as the sum of neighbor's in-degree. 
        Foreach (s: G.Nodes) {                
            s.NSum = Sum(t:s.Nbrs) { t.InDegree() }; 
        }        
        
        // return the sum of NSum over all nodes
        Return Sum(s: G.Nodes) {s.NSum};     
    }

The above code should be self-explantory with the comments. Note that in fact, the code itself can be
as intuitive as the textual explanation once you understand the syntax. 

We can compile this code with gm_comp just the same as in the previous section.

    cd $(top)/apps
    make gen         %% this command generates .cc file out of .gm file
    
Before we go, let us check the generated _header_ file:

    cat $(top)/apps/output_cpp/generated/hello_world.h
    %% It should look like as follows:
    #ifndef GM_GENERATED_CPP_HELLO_WORLD_H
    #define GM_GENERATED_CPP_HELLO_WORLD_H
    
    #include <stdio>                  // include for standard C/C++ libraries
       // .... a few more includes
    #include <omp.h>                  // include for OpenMP
    #include "gm.h"                   // include for Runtime and Graph library            
    
    void hello_world();               // your 1st procedure
    int32_t sum_of_nbrs_in_degree(    // your 2nd procedure
       gm_graph& G, int32_t* G_val);  //   arguments of the procedure
    
    #endif
    

3-2 Another main program
--------------------------------------

Now let us modify main function as well. In this new main function, we will build up a graph 
and make a call to `sum_of_nbr_ini_degree()` function. 

Edit $(top)/apps/output_cpp/src/hello_world_main.cc ss follows:


    int main(int argc, char** argv)
    {
        hello_world();               // call to the generated function
        
        // create an empty graph
        gm_graph G;
        
        // Add 5 nodes in the graph; 
        // Node 0~4 is created.
        for(int i=0;i<5;i++) 
            G.add_node();

        // Add following Edges such that
        //  node 3 has four in-neighbors (node 0,1,2,4) while 4 has one (node 0).
        G.add_edge(0,3); //  0->3
        G.add_edge(1,3); //  1->3
        G.add_edge(2,3); //  2->3
        G.add_edge(4,3); //  4->3
        G.add_edge(0,4); //  0->4


        // Create an array to hold the node property
        int32_t nsum = new int32_t[G.num_nodes()];
        
        // call to your procedure
        int32_t s = sum_of_nbrs_in_degree(G, nsum);
        
        // print out the results
        printf("[
        for(int i=0;i<5;i++)
           printf("%d ", s[i]);
        printf("]\n");
        printf("total sum = %d\n", s);
    }

The result should be like as follows:

     [5 4 4 0 4 ]    %% nsum value for each node
     total sum = 17  %% total sum of nsum


3-3 Looking inside the generated code
--------------------------------------



4 Further information
======================================

Please refer to the following documents for further information

* Green-Marl language specification : about the language (syntax and semantic)
* compiler.txt : about gm_comp compiler
* gm_graph.txt : about c++ runtime and graph library.

